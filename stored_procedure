CREATE TABLE DoctorSchedule (
    DoctorID INT,
    DoctorSlotIndex INT,
    DoctorAvailableFrom TIME,
    DoctorAvailableTo TIME,
    DoctorAvailableDays INT,  -- Use numbers to represent days (e.g., 123 for Mon, Tue, Sat)
    SlotsPerDay INT  -- Number of slots per day
);

INSERT INTO DoctorSchedule (DoctorID, DoctorSlotIndex, DoctorAvailableFrom, DoctorAvailableTo, DoctorAvailableDays, SlotsPerDay)
VALUES
    (1, 2, '08:00:00', '17:00:00', 123, 10),  -- Monday, Tuesday, Saturday, 10 slots per day
    (2, 2, '09:00:00', '16:00:00', 124, 8),   -- Monday, Wednesday, Friday, 8 slots per day
    (3, 2, '10:00:00', '15:00:00', 23, 6),    -- Tuesday, Thursday, 6 slots per day
    (4, 2, '08:30:00', '18:00:00', 24, 9),    -- Wednesday, Friday, 9 slots per day
    (5, 2, '11:00:00', '14:00:00', 3, 7),     -- Thursday, 7 slots per day
    (1, 1, '08:00:00', '17:00:00', 123, 10),  -- Monday, Tuesday, Saturday, 10 slots per day
    (2, 1, '09:00:00', '16:00:00', 124, 8),   -- Monday, Wednesday, Friday, 8 slots per day
    (3, 1, '10:00:00', '15:00:00', 23, 6),    -- Tuesday, Thursday, 6 slots per day
    (4, 1, '08:30:00', '18:00:00', 24, 9),    -- Wednesday, Friday, 9 slots per day
    (5, 1, '11:00:00', '14:00:00', 3, 7);     -- Thursday, 7 slots per day


CREATE TABLE DoctorAvailability (
    DoctorID INT,
    DaysToBook INT
);


-- Insert data into DoctorAvailability
INSERT INTO DoctorAvailability (DoctorID, DaysToBook)
VALUES
    (1, 10),  -- Doctor 1 allows 10 days to be booked
    (2, 7),   -- Doctor 2 allows 7 days to be booked
    (3, 14);  -- Doctor 3 allows 14 days to be booked







*****************************count working days doctoor***********************
SELECT
    DoctorID,
    SUM(length(regexp_replace(DoctorAvailableDays::text, '0', '', 'g'))) AS WorkingDaysCount
FROM
    DoctorScheduleyesu
GROUP BY
    DoctorID;





**********************************************************************************
CREATE OR REPLACE FUNCTION CalculateWorkingDays() RETURNS VARCHAR(500) AS $$
DECLARE 
    done BOOLEAN := FALSE;
    v_doctorID INT;
    processDate DATE := '2023-09-04';  -- Set your desired date here
    result VARCHAR(500) := '';
    doctorRecord RECORD;  -- Declare a record variable to hold the query result

BEGIN
    -- Loop through DoctorID and WorkingDaysCount
    FOR doctorRecord IN 
        SELECT ds.DoctorID, SUM(length(regexp_replace(ds.DoctorAvailableDays::text, '0', '', 'g'))) AS WorkingDaysCount
        FROM DoctorScheduleyesu ds
        GROUP BY ds.DoctorID
    LOOP
        v_doctorID := doctorRecord.DoctorID;
        -- Call the process function for each doctor with processDate as a parameter
        PERFORM process(v_doctorID, doctorRecord.WorkingDaysCount, processDate);
    END LOOP;
    
    RETURN 'Success'; -- Replace with the actual result you want to return
END;
$$ LANGUAGE plpgsql;




SELECT CalculateWorkingDays();





CREATE OR REPLACE FUNCTION process(
    IN inDoctorID INT, 
    IN inWorkingDaysCount BIGINT, 
    IN inProcessDate DATE
) 
RETURNS VOID AS $$
DECLARE 
    done BOOLEAN := FALSE;
    doctorAvailabilityID INT;
    totalDays INT;
    remainingDays INT;
    nextDate DATE;  -- Variable to store the calculated date
    availabilityRecord RECORD;
    processdate DATE; -- Declare processdate variable
    nextDayOfWeek INT; -- Declare nextDayOfWeek variable

BEGIN
    -- Initialize remainingDays with totalDays
   -- You should initialize it to 0

    -- Cursor to fetch DaysToBook from DoctorAvailability
    FOR availabilityRecord IN 
        SELECT DaysToBook
        FROM DoctorAvailability
        WHERE DoctorID = inDoctorID
    LOOP
        totalDays := availabilityRecord.DaysToBook;
        
        -- Set the remainingDays to a specific value (in this case, 5)
        SElect  (totalDays-inWorkingDaysCount) into remainingDays;

        -- Calculate the nextDate by adding remainingDays to inProcessDate
        processdate := inProcessDate + remainingDays;

        -- Get the specific day of the week as an integer (Monday = 1, Tuesday = 2, etc.)
        SELECT EXTRACT(DOW FROM processdate) INTO nextDayOfWeek;

        -- Call the getdata function for further processing
        PERFORM getdata(nextDayOfWeek, inDoctorID, processdate, remainingDays);

        -- You can use nextDayOfWeek as needed for further processing
    END LOOP;
END;
$$ LANGUAGE plpgsql;








CREATE OR REPLACE FUNCTION getdata(
    IN inNextDayOfWeek INT, 
    IN inDoctorID INT, 
    IN inProcessDate DATE, 
    IN remainingDays INT
) 
RETURNS SETOF DoctorScheduleInfo AS $$
DECLARE 
    done INT;
    doctorScheduleID INT;
    doctorAvailableDays VARCHAR(7); -- Assuming DoctorAvailableDays is a VARCHAR with a length of 7
    doctoravailablefrom_var TIME;
    doctoravailableto_var TIME;
    doctoravilableslot_var INT;

    scheduleRecord RECORD;  -- Declare a record variable

BEGIN
    -- Cursor to fetch DoctorSchedule_ID and DoctorAvailableDays
    FOR scheduleRecord IN 
        SELECT doctorid, doctorschedule
        FROM DoctorSchedule_Bhaskar
        WHERE DoctorID = inDoctorID
    LOOP
        doctorScheduleID := scheduleRecord.doctorid;
        doctorAvailableDays := scheduleRecord.doctorschedule;

        -- Check if nextDayOfWeek is found in the DoctorAvailableDays
        IF SUBSTRING(doctorAvailableDays, inNextDayOfWeek, 1) = '1' THEN
            SELECT doctoravailablefrom, doctoravailableto, doctoravilableslot
            INTO doctoravailablefrom_var, doctoravailableto_var, doctoravilableslot_var
            FROM DoctorSchedule_Bhaskar
            WHERE DoctorSchedule_ID = doctorScheduleID;

            -- Calculate updatedTimeFrom and updatedTimeTo
            doctoravailablefrom_var := doctoravailablefrom_var;
            doctoravailableto_var := doctoravailablefrom_var + (doctoravilableslot_var || ' minutes')::INTERVAL;

            -- Optionally, you can accumulate matchingDates or use it as needed
            -- matchingDates := CONCAT(matchingDates, ',', doctorScheduleID);

            -- Return the data as a row of the custom type
            RETURN NEXT (doctoravailablefrom_var, doctoravailableto_var, doctoravilableslot_var);

            -- Perform any other processing or calculations you need
        END IF;
    END LOOP;

    -- Done looping, close the function
    RETURN;
END;
$$ LANGUAGE plpgsql;



sELECT *
        FROM DoctorSchedule_Bhaskar;
		
		
-- Define a custom type to hold the data
CREATE TYPE DoctorScheduleInfo AS (
    doctoravailablefrom TIME,
    doctoravailableto TIME,
    doctoravilableslot INT
);

        
DROP FUNCTION getdata(integer,integer,date,integer);
